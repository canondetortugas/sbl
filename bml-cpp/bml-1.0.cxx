// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "bml-1.0.hxx"

namespace bml
{
  // requiredType
  // 

  const requiredType::constraint_sequence& requiredType::
  constraint () const
  {
    return this->constraint_;
  }

  requiredType::constraint_sequence& requiredType::
  constraint ()
  {
    return this->constraint_;
  }

  void requiredType::
  constraint (const constraint_sequence& s)
  {
    this->constraint_ = s;
  }

  const requiredType::gaze_sequence& requiredType::
  gaze () const
  {
    return this->gaze_;
  }

  requiredType::gaze_sequence& requiredType::
  gaze ()
  {
    return this->gaze_;
  }

  void requiredType::
  gaze (const gaze_sequence& s)
  {
    this->gaze_ = s;
  }

  const requiredType::wait_sequence& requiredType::
  wait () const
  {
    return this->wait_;
  }

  requiredType::wait_sequence& requiredType::
  wait ()
  {
    return this->wait_;
  }

  void requiredType::
  wait (const wait_sequence& s)
  {
    this->wait_ = s;
  }

  const requiredType::headOrientation_sequence& requiredType::
  headOrientation () const
  {
    return this->headOrientation_;
  }

  requiredType::headOrientation_sequence& requiredType::
  headOrientation ()
  {
    return this->headOrientation_;
  }

  void requiredType::
  headOrientation (const headOrientation_sequence& s)
  {
    this->headOrientation_ = s;
  }

  const requiredType::posture_sequence& requiredType::
  posture () const
  {
    return this->posture_;
  }

  requiredType::posture_sequence& requiredType::
  posture ()
  {
    return this->posture_;
  }

  void requiredType::
  posture (const posture_sequence& s)
  {
    this->posture_ = s;
  }

  const requiredType::postureShift_sequence& requiredType::
  postureShift () const
  {
    return this->postureShift_;
  }

  requiredType::postureShift_sequence& requiredType::
  postureShift ()
  {
    return this->postureShift_;
  }

  void requiredType::
  postureShift (const postureShift_sequence& s)
  {
    this->postureShift_ = s;
  }

  const requiredType::speech_sequence& requiredType::
  speech () const
  {
    return this->speech_;
  }

  requiredType::speech_sequence& requiredType::
  speech ()
  {
    return this->speech_;
  }

  void requiredType::
  speech (const speech_sequence& s)
  {
    this->speech_ = s;
  }

  const requiredType::gesture_sequence& requiredType::
  gesture () const
  {
    return this->gesture_;
  }

  requiredType::gesture_sequence& requiredType::
  gesture ()
  {
    return this->gesture_;
  }

  void requiredType::
  gesture (const gesture_sequence& s)
  {
    this->gesture_ = s;
  }

  const requiredType::pointing_sequence& requiredType::
  pointing () const
  {
    return this->pointing_;
  }

  requiredType::pointing_sequence& requiredType::
  pointing ()
  {
    return this->pointing_;
  }

  void requiredType::
  pointing (const pointing_sequence& s)
  {
    this->pointing_ = s;
  }

  const requiredType::face_sequence& requiredType::
  face () const
  {
    return this->face_;
  }

  requiredType::face_sequence& requiredType::
  face ()
  {
    return this->face_;
  }

  void requiredType::
  face (const face_sequence& s)
  {
    this->face_ = s;
  }

  const requiredType::faceLexeme_sequence& requiredType::
  faceLexeme () const
  {
    return this->faceLexeme_;
  }

  requiredType::faceLexeme_sequence& requiredType::
  faceLexeme ()
  {
    return this->faceLexeme_;
  }

  void requiredType::
  faceLexeme (const faceLexeme_sequence& s)
  {
    this->faceLexeme_ = s;
  }

  const requiredType::locomotion_sequence& requiredType::
  locomotion () const
  {
    return this->locomotion_;
  }

  requiredType::locomotion_sequence& requiredType::
  locomotion ()
  {
    return this->locomotion_;
  }

  void requiredType::
  locomotion (const locomotion_sequence& s)
  {
    this->locomotion_ = s;
  }

  const requiredType::head_sequence& requiredType::
  head () const
  {
    return this->head_;
  }

  requiredType::head_sequence& requiredType::
  head ()
  {
    return this->head_;
  }

  void requiredType::
  head (const head_sequence& s)
  {
    this->head_ = s;
  }

  const requiredType::headDirectionShift_sequence& requiredType::
  headDirectionShift () const
  {
    return this->headDirectionShift_;
  }

  requiredType::headDirectionShift_sequence& requiredType::
  headDirectionShift ()
  {
    return this->headDirectionShift_;
  }

  void requiredType::
  headDirectionShift (const headDirectionShift_sequence& s)
  {
    this->headDirectionShift_ = s;
  }


  // behaviorType
  // 

  const behaviorType::id_type& behaviorType::
  id () const
  {
    return this->id_.get ();
  }

  behaviorType::id_type& behaviorType::
  id ()
  {
    return this->id_.get ();
  }

  void behaviorType::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void behaviorType::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const behaviorType::start_optional& behaviorType::
  start () const
  {
    return this->start_;
  }

  behaviorType::start_optional& behaviorType::
  start ()
  {
    return this->start_;
  }

  void behaviorType::
  start (const start_type& x)
  {
    this->start_.set (x);
  }

  void behaviorType::
  start (const start_optional& x)
  {
    this->start_ = x;
  }

  void behaviorType::
  start (::std::auto_ptr< start_type > x)
  {
    this->start_.set (x);
  }

  const behaviorType::end_optional& behaviorType::
  end () const
  {
    return this->end_;
  }

  behaviorType::end_optional& behaviorType::
  end ()
  {
    return this->end_;
  }

  void behaviorType::
  end (const end_type& x)
  {
    this->end_.set (x);
  }

  void behaviorType::
  end (const end_optional& x)
  {
    this->end_ = x;
  }

  void behaviorType::
  end (::std::auto_ptr< end_type > x)
  {
    this->end_.set (x);
  }


  // constraintType
  // 

  const constraintType::synchronize_optional& constraintType::
  synchronize () const
  {
    return this->synchronize_;
  }

  constraintType::synchronize_optional& constraintType::
  synchronize ()
  {
    return this->synchronize_;
  }

  void constraintType::
  synchronize (const synchronize_type& x)
  {
    this->synchronize_.set (x);
  }

  void constraintType::
  synchronize (const synchronize_optional& x)
  {
    this->synchronize_ = x;
  }

  void constraintType::
  synchronize (::std::auto_ptr< synchronize_type > x)
  {
    this->synchronize_.set (x);
  }

  const constraintType::before_optional& constraintType::
  before () const
  {
    return this->before_;
  }

  constraintType::before_optional& constraintType::
  before ()
  {
    return this->before_;
  }

  void constraintType::
  before (const before_type& x)
  {
    this->before_.set (x);
  }

  void constraintType::
  before (const before_optional& x)
  {
    this->before_ = x;
  }

  void constraintType::
  before (::std::auto_ptr< before_type > x)
  {
    this->before_.set (x);
  }

  const constraintType::after_optional& constraintType::
  after () const
  {
    return this->after_;
  }

  constraintType::after_optional& constraintType::
  after ()
  {
    return this->after_;
  }

  void constraintType::
  after (const after_type& x)
  {
    this->after_.set (x);
  }

  void constraintType::
  after (const after_optional& x)
  {
    this->after_ = x;
  }

  void constraintType::
  after (::std::auto_ptr< after_type > x)
  {
    this->after_.set (x);
  }


  // synchronizeType
  // 

  const synchronizeType::sync_sequence& synchronizeType::
  sync () const
  {
    return this->sync_;
  }

  synchronizeType::sync_sequence& synchronizeType::
  sync ()
  {
    return this->sync_;
  }

  void synchronizeType::
  sync (const sync_sequence& s)
  {
    this->sync_ = s;
  }


  // beforeType
  // 

  const beforeType::ref_optional& beforeType::
  ref () const
  {
    return this->ref_;
  }

  beforeType::ref_optional& beforeType::
  ref ()
  {
    return this->ref_;
  }

  void beforeType::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void beforeType::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void beforeType::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }


  // afterType
  // 

  const afterType::ref_optional& afterType::
  ref () const
  {
    return this->ref_;
  }

  afterType::ref_optional& afterType::
  ref ()
  {
    return this->ref_;
  }

  void afterType::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void afterType::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void afterType::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }


  // syncRefType
  // 

  const syncRefType::ref_optional& syncRefType::
  ref () const
  {
    return this->ref_;
  }

  syncRefType::ref_optional& syncRefType::
  ref ()
  {
    return this->ref_;
  }

  void syncRefType::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void syncRefType::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void syncRefType::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }


  // waitType
  // 

  const waitType::duration_optional& waitType::
  duration () const
  {
    return this->duration_;
  }

  waitType::duration_optional& waitType::
  duration ()
  {
    return this->duration_;
  }

  void waitType::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void waitType::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }


  // gazeType
  // 

  const gazeType::target_optional& gazeType::
  target () const
  {
    return this->target_;
  }

  gazeType::target_optional& gazeType::
  target ()
  {
    return this->target_;
  }

  void gazeType::
  target (const target_type& x)
  {
    this->target_.set (x);
  }

  void gazeType::
  target (const target_optional& x)
  {
    this->target_ = x;
  }

  void gazeType::
  target (::std::auto_ptr< target_type > x)
  {
    this->target_.set (x);
  }

  const gazeType::influence_optional& gazeType::
  influence () const
  {
    return this->influence_;
  }

  gazeType::influence_optional& gazeType::
  influence ()
  {
    return this->influence_;
  }

  void gazeType::
  influence (const influence_type& x)
  {
    this->influence_.set (x);
  }

  void gazeType::
  influence (const influence_optional& x)
  {
    this->influence_ = x;
  }

  void gazeType::
  influence (::std::auto_ptr< influence_type > x)
  {
    this->influence_.set (x);
  }

  const gazeType::ready_optional& gazeType::
  ready () const
  {
    return this->ready_;
  }

  gazeType::ready_optional& gazeType::
  ready ()
  {
    return this->ready_;
  }

  void gazeType::
  ready (const ready_type& x)
  {
    this->ready_.set (x);
  }

  void gazeType::
  ready (const ready_optional& x)
  {
    this->ready_ = x;
  }

  void gazeType::
  ready (::std::auto_ptr< ready_type > x)
  {
    this->ready_.set (x);
  }

  const gazeType::relax_optional& gazeType::
  relax () const
  {
    return this->relax_;
  }

  gazeType::relax_optional& gazeType::
  relax ()
  {
    return this->relax_;
  }

  void gazeType::
  relax (const relax_type& x)
  {
    this->relax_.set (x);
  }

  void gazeType::
  relax (const relax_optional& x)
  {
    this->relax_ = x;
  }

  void gazeType::
  relax (::std::auto_ptr< relax_type > x)
  {
    this->relax_.set (x);
  }

  const gazeType::offsetAngle_optional& gazeType::
  offsetAngle () const
  {
    return this->offsetAngle_;
  }

  gazeType::offsetAngle_optional& gazeType::
  offsetAngle ()
  {
    return this->offsetAngle_;
  }

  void gazeType::
  offsetAngle (const offsetAngle_type& x)
  {
    this->offsetAngle_.set (x);
  }

  void gazeType::
  offsetAngle (const offsetAngle_optional& x)
  {
    this->offsetAngle_ = x;
  }

  const gazeType::offsetDirection_optional& gazeType::
  offsetDirection () const
  {
    return this->offsetDirection_;
  }

  gazeType::offsetDirection_optional& gazeType::
  offsetDirection ()
  {
    return this->offsetDirection_;
  }

  void gazeType::
  offsetDirection (const offsetDirection_type& x)
  {
    this->offsetDirection_.set (x);
  }

  void gazeType::
  offsetDirection (const offsetDirection_optional& x)
  {
    this->offsetDirection_ = x;
  }

  void gazeType::
  offsetDirection (::std::auto_ptr< offsetDirection_type > x)
  {
    this->offsetDirection_.set (x);
  }


  // gestureType
  // 

  const gestureType::lexeme_optional& gestureType::
  lexeme () const
  {
    return this->lexeme_;
  }

  gestureType::lexeme_optional& gestureType::
  lexeme ()
  {
    return this->lexeme_;
  }

  void gestureType::
  lexeme (const lexeme_type& x)
  {
    this->lexeme_.set (x);
  }

  void gestureType::
  lexeme (const lexeme_optional& x)
  {
    this->lexeme_ = x;
  }

  void gestureType::
  lexeme (::std::auto_ptr< lexeme_type > x)
  {
    this->lexeme_.set (x);
  }

  const gestureType::mode_optional& gestureType::
  mode () const
  {
    return this->mode_;
  }

  gestureType::mode_optional& gestureType::
  mode ()
  {
    return this->mode_;
  }

  void gestureType::
  mode (const mode_type& x)
  {
    this->mode_.set (x);
  }

  void gestureType::
  mode (const mode_optional& x)
  {
    this->mode_ = x;
  }

  void gestureType::
  mode (::std::auto_ptr< mode_type > x)
  {
    this->mode_.set (x);
  }

  const gestureType::strokeStart_optional& gestureType::
  strokeStart () const
  {
    return this->strokeStart_;
  }

  gestureType::strokeStart_optional& gestureType::
  strokeStart ()
  {
    return this->strokeStart_;
  }

  void gestureType::
  strokeStart (const strokeStart_type& x)
  {
    this->strokeStart_.set (x);
  }

  void gestureType::
  strokeStart (const strokeStart_optional& x)
  {
    this->strokeStart_ = x;
  }

  void gestureType::
  strokeStart (::std::auto_ptr< strokeStart_type > x)
  {
    this->strokeStart_.set (x);
  }

  const gestureType::stroke_optional& gestureType::
  stroke () const
  {
    return this->stroke_;
  }

  gestureType::stroke_optional& gestureType::
  stroke ()
  {
    return this->stroke_;
  }

  void gestureType::
  stroke (const stroke_type& x)
  {
    this->stroke_.set (x);
  }

  void gestureType::
  stroke (const stroke_optional& x)
  {
    this->stroke_ = x;
  }

  void gestureType::
  stroke (::std::auto_ptr< stroke_type > x)
  {
    this->stroke_.set (x);
  }

  const gestureType::strokeEnd_optional& gestureType::
  strokeEnd () const
  {
    return this->strokeEnd_;
  }

  gestureType::strokeEnd_optional& gestureType::
  strokeEnd ()
  {
    return this->strokeEnd_;
  }

  void gestureType::
  strokeEnd (const strokeEnd_type& x)
  {
    this->strokeEnd_.set (x);
  }

  void gestureType::
  strokeEnd (const strokeEnd_optional& x)
  {
    this->strokeEnd_ = x;
  }

  void gestureType::
  strokeEnd (::std::auto_ptr< strokeEnd_type > x)
  {
    this->strokeEnd_.set (x);
  }

  const gestureType::relax_optional& gestureType::
  relax () const
  {
    return this->relax_;
  }

  gestureType::relax_optional& gestureType::
  relax ()
  {
    return this->relax_;
  }

  void gestureType::
  relax (const relax_type& x)
  {
    this->relax_.set (x);
  }

  void gestureType::
  relax (const relax_optional& x)
  {
    this->relax_ = x;
  }

  void gestureType::
  relax (::std::auto_ptr< relax_type > x)
  {
    this->relax_.set (x);
  }

  const gestureType::ready_optional& gestureType::
  ready () const
  {
    return this->ready_;
  }

  gestureType::ready_optional& gestureType::
  ready ()
  {
    return this->ready_;
  }

  void gestureType::
  ready (const ready_type& x)
  {
    this->ready_.set (x);
  }

  void gestureType::
  ready (const ready_optional& x)
  {
    this->ready_ = x;
  }

  void gestureType::
  ready (::std::auto_ptr< ready_type > x)
  {
    this->ready_.set (x);
  }


  // syncType
  // 

  const syncType::id_optional& syncType::
  id () const
  {
    return this->id_;
  }

  syncType::id_optional& syncType::
  id ()
  {
    return this->id_;
  }

  void syncType::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void syncType::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void syncType::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }


  // textType
  // 

  const textType::sync_sequence& textType::
  sync () const
  {
    return this->sync_;
  }

  textType::sync_sequence& textType::
  sync ()
  {
    return this->sync_;
  }

  void textType::
  sync (const sync_sequence& s)
  {
    this->sync_ = s;
  }


  // speech
  // 

  const speech::text_sequence& speech::
  text () const
  {
    return this->text_;
  }

  speech::text_sequence& speech::
  text ()
  {
    return this->text_;
  }

  void speech::
  text (const text_sequence& s)
  {
    this->text_ = s;
  }


  // postureType
  // 

  const postureType::pose_sequence& postureType::
  pose () const
  {
    return this->pose_;
  }

  postureType::pose_sequence& postureType::
  pose ()
  {
    return this->pose_;
  }

  void postureType::
  pose (const pose_sequence& s)
  {
    this->pose_ = s;
  }

  const postureType::stance_optional& postureType::
  stance () const
  {
    return this->stance_;
  }

  postureType::stance_optional& postureType::
  stance ()
  {
    return this->stance_;
  }

  void postureType::
  stance (const stance_type& x)
  {
    this->stance_.set (x);
  }

  void postureType::
  stance (const stance_optional& x)
  {
    this->stance_ = x;
  }

  void postureType::
  stance (::std::auto_ptr< stance_type > x)
  {
    this->stance_.set (x);
  }

  const postureType::ready_optional& postureType::
  ready () const
  {
    return this->ready_;
  }

  postureType::ready_optional& postureType::
  ready ()
  {
    return this->ready_;
  }

  void postureType::
  ready (const ready_type& x)
  {
    this->ready_.set (x);
  }

  void postureType::
  ready (const ready_optional& x)
  {
    this->ready_ = x;
  }

  void postureType::
  ready (::std::auto_ptr< ready_type > x)
  {
    this->ready_.set (x);
  }

  const postureType::relax_optional& postureType::
  relax () const
  {
    return this->relax_;
  }

  postureType::relax_optional& postureType::
  relax ()
  {
    return this->relax_;
  }

  void postureType::
  relax (const relax_type& x)
  {
    this->relax_.set (x);
  }

  void postureType::
  relax (const relax_optional& x)
  {
    this->relax_ = x;
  }

  void postureType::
  relax (::std::auto_ptr< relax_type > x)
  {
    this->relax_.set (x);
  }


  // faceAbstractType
  // 

  const faceAbstractType::amount_type& faceAbstractType::
  amount () const
  {
    return this->amount_.get ();
  }

  faceAbstractType::amount_type& faceAbstractType::
  amount ()
  {
    return this->amount_.get ();
  }

  void faceAbstractType::
  amount (const amount_type& x)
  {
    this->amount_.set (x);
  }

  faceAbstractType::amount_type faceAbstractType::
  amount_default_value ()
  {
    return amount_type (.5F);
  }

  const faceAbstractType::attackPeak_optional& faceAbstractType::
  attackPeak () const
  {
    return this->attackPeak_;
  }

  faceAbstractType::attackPeak_optional& faceAbstractType::
  attackPeak ()
  {
    return this->attackPeak_;
  }

  void faceAbstractType::
  attackPeak (const attackPeak_type& x)
  {
    this->attackPeak_.set (x);
  }

  void faceAbstractType::
  attackPeak (const attackPeak_optional& x)
  {
    this->attackPeak_ = x;
  }

  void faceAbstractType::
  attackPeak (::std::auto_ptr< attackPeak_type > x)
  {
    this->attackPeak_.set (x);
  }

  const faceAbstractType::relax_optional& faceAbstractType::
  relax () const
  {
    return this->relax_;
  }

  faceAbstractType::relax_optional& faceAbstractType::
  relax ()
  {
    return this->relax_;
  }

  void faceAbstractType::
  relax (const relax_type& x)
  {
    this->relax_.set (x);
  }

  void faceAbstractType::
  relax (const relax_optional& x)
  {
    this->relax_ = x;
  }

  void faceAbstractType::
  relax (::std::auto_ptr< relax_type > x)
  {
    this->relax_.set (x);
  }


  // faceLexemeType
  // 

  const faceLexemeType::lexeme_type& faceLexemeType::
  lexeme () const
  {
    return this->lexeme_.get ();
  }

  faceLexemeType::lexeme_type& faceLexemeType::
  lexeme ()
  {
    return this->lexeme_.get ();
  }

  void faceLexemeType::
  lexeme (const lexeme_type& x)
  {
    this->lexeme_.set (x);
  }

  void faceLexemeType::
  lexeme (::std::auto_ptr< lexeme_type > x)
  {
    this->lexeme_.set (x);
  }


  // syncBlock
  // 

  const syncBlock::sync_sequence& syncBlock::
  sync () const
  {
    return this->sync_;
  }

  syncBlock::sync_sequence& syncBlock::
  sync ()
  {
    return this->sync_;
  }

  void syncBlock::
  sync (const sync_sequence& s)
  {
    this->sync_ = s;
  }

  const syncBlock::ref_optional& syncBlock::
  ref () const
  {
    return this->ref_;
  }

  syncBlock::ref_optional& syncBlock::
  ref ()
  {
    return this->ref_;
  }

  void syncBlock::
  ref (const ref_type& x)
  {
    this->ref_.set (x);
  }

  void syncBlock::
  ref (const ref_optional& x)
  {
    this->ref_ = x;
  }

  void syncBlock::
  ref (::std::auto_ptr< ref_type > x)
  {
    this->ref_.set (x);
  }


  // targetID
  // 


  // id
  // 


  // openSetItem
  //

  openSetItem::
  openSetItem ()
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > ( ::xml_schema::flags (0), this)
  {
  }

  openSetItem::
  openSetItem (size_type n, const ::xml_schema::string& x)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
  {
  }

  openSetItem::
  openSetItem (const openSetItem& o,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
  {
  }

  // closedSetItem
  //

  closedSetItem::
  closedSetItem ()
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > ( ::xml_schema::flags (0), this)
  {
  }

  closedSetItem::
  closedSetItem (size_type n, const ::xml_schema::string& x)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
  {
  }

  closedSetItem::
  closedSetItem (const closedSetItem& o,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
  {
  }

  // pointingType
  // 

  const pointingType::target_optional& pointingType::
  target () const
  {
    return this->target_;
  }

  pointingType::target_optional& pointingType::
  target ()
  {
    return this->target_;
  }

  void pointingType::
  target (const target_type& x)
  {
    this->target_.set (x);
  }

  void pointingType::
  target (const target_optional& x)
  {
    this->target_ = x;
  }

  void pointingType::
  target (::std::auto_ptr< target_type > x)
  {
    this->target_.set (x);
  }

  const pointingType::mode_optional& pointingType::
  mode () const
  {
    return this->mode_;
  }

  pointingType::mode_optional& pointingType::
  mode ()
  {
    return this->mode_;
  }

  void pointingType::
  mode (const mode_type& x)
  {
    this->mode_.set (x);
  }

  void pointingType::
  mode (const mode_optional& x)
  {
    this->mode_ = x;
  }

  void pointingType::
  mode (::std::auto_ptr< mode_type > x)
  {
    this->mode_.set (x);
  }

  const pointingType::ready_optional& pointingType::
  ready () const
  {
    return this->ready_;
  }

  pointingType::ready_optional& pointingType::
  ready ()
  {
    return this->ready_;
  }

  void pointingType::
  ready (const ready_type& x)
  {
    this->ready_.set (x);
  }

  void pointingType::
  ready (const ready_optional& x)
  {
    this->ready_ = x;
  }

  void pointingType::
  ready (::std::auto_ptr< ready_type > x)
  {
    this->ready_.set (x);
  }

  const pointingType::strokeStart_optional& pointingType::
  strokeStart () const
  {
    return this->strokeStart_;
  }

  pointingType::strokeStart_optional& pointingType::
  strokeStart ()
  {
    return this->strokeStart_;
  }

  void pointingType::
  strokeStart (const strokeStart_type& x)
  {
    this->strokeStart_.set (x);
  }

  void pointingType::
  strokeStart (const strokeStart_optional& x)
  {
    this->strokeStart_ = x;
  }

  void pointingType::
  strokeStart (::std::auto_ptr< strokeStart_type > x)
  {
    this->strokeStart_.set (x);
  }

  const pointingType::stroke_optional& pointingType::
  stroke () const
  {
    return this->stroke_;
  }

  pointingType::stroke_optional& pointingType::
  stroke ()
  {
    return this->stroke_;
  }

  void pointingType::
  stroke (const stroke_type& x)
  {
    this->stroke_.set (x);
  }

  void pointingType::
  stroke (const stroke_optional& x)
  {
    this->stroke_ = x;
  }

  void pointingType::
  stroke (::std::auto_ptr< stroke_type > x)
  {
    this->stroke_.set (x);
  }

  const pointingType::strokeEnd_optional& pointingType::
  strokeEnd () const
  {
    return this->strokeEnd_;
  }

  pointingType::strokeEnd_optional& pointingType::
  strokeEnd ()
  {
    return this->strokeEnd_;
  }

  void pointingType::
  strokeEnd (const strokeEnd_type& x)
  {
    this->strokeEnd_.set (x);
  }

  void pointingType::
  strokeEnd (const strokeEnd_optional& x)
  {
    this->strokeEnd_ = x;
  }

  void pointingType::
  strokeEnd (::std::auto_ptr< strokeEnd_type > x)
  {
    this->strokeEnd_.set (x);
  }

  const pointingType::relax_optional& pointingType::
  relax () const
  {
    return this->relax_;
  }

  pointingType::relax_optional& pointingType::
  relax ()
  {
    return this->relax_;
  }

  void pointingType::
  relax (const relax_type& x)
  {
    this->relax_.set (x);
  }

  void pointingType::
  relax (const relax_optional& x)
  {
    this->relax_ = x;
  }

  void pointingType::
  relax (::std::auto_ptr< relax_type > x)
  {
    this->relax_.set (x);
  }


  // locomotionType
  // 

  const locomotionType::manner_optional& locomotionType::
  manner () const
  {
    return this->manner_;
  }

  locomotionType::manner_optional& locomotionType::
  manner ()
  {
    return this->manner_;
  }

  void locomotionType::
  manner (const manner_type& x)
  {
    this->manner_.set (x);
  }

  void locomotionType::
  manner (const manner_optional& x)
  {
    this->manner_ = x;
  }

  void locomotionType::
  manner (::std::auto_ptr< manner_type > x)
  {
    this->manner_.set (x);
  }

  const locomotionType::target_optional& locomotionType::
  target () const
  {
    return this->target_;
  }

  locomotionType::target_optional& locomotionType::
  target ()
  {
    return this->target_;
  }

  void locomotionType::
  target (const target_type& x)
  {
    this->target_.set (x);
  }

  void locomotionType::
  target (const target_optional& x)
  {
    this->target_ = x;
  }

  void locomotionType::
  target (::std::auto_ptr< target_type > x)
  {
    this->target_.set (x);
  }


  // headDirectionShiftType
  // 

  const headDirectionShiftType::target_type& headDirectionShiftType::
  target () const
  {
    return this->target_.get ();
  }

  headDirectionShiftType::target_type& headDirectionShiftType::
  target ()
  {
    return this->target_.get ();
  }

  void headDirectionShiftType::
  target (const target_type& x)
  {
    this->target_.set (x);
  }

  void headDirectionShiftType::
  target (::std::auto_ptr< target_type > x)
  {
    this->target_.set (x);
  }


  // faceFacs
  // 

  const faceFacs::au_type& faceFacs::
  au () const
  {
    return this->au_.get ();
  }

  faceFacs::au_type& faceFacs::
  au ()
  {
    return this->au_.get ();
  }

  void faceFacs::
  au (const au_type& x)
  {
    this->au_.set (x);
  }

  const faceFacs::side_type& faceFacs::
  side () const
  {
    return this->side_.get ();
  }

  faceFacs::side_type& faceFacs::
  side ()
  {
    return this->side_.get ();
  }

  void faceFacs::
  side (const side_type& x)
  {
    this->side_.set (x);
  }

  void faceFacs::
  side (::std::auto_ptr< side_type > x)
  {
    this->side_.set (x);
  }

  const faceFacs::side_type& faceFacs::
  side_default_value ()
  {
    return side_default_value_;
  }


  // faceType
  // 

  const faceType::lexeme_type& faceType::
  lexeme () const
  {
    return this->lexeme_.get ();
  }

  faceType::lexeme_type& faceType::
  lexeme ()
  {
    return this->lexeme_.get ();
  }

  void faceType::
  lexeme (const lexeme_type& x)
  {
    this->lexeme_.set (x);
  }

  void faceType::
  lexeme (::std::auto_ptr< lexeme_type > x)
  {
    this->lexeme_.set (x);
  }


  // faceShiftType
  // 

  const faceShiftType::lexeme_type& faceShiftType::
  lexeme () const
  {
    return this->lexeme_.get ();
  }

  faceShiftType::lexeme_type& faceShiftType::
  lexeme ()
  {
    return this->lexeme_.get ();
  }

  void faceShiftType::
  lexeme (const lexeme_type& x)
  {
    this->lexeme_.set (x);
  }

  void faceShiftType::
  lexeme (::std::auto_ptr< lexeme_type > x)
  {
    this->lexeme_.set (x);
  }


  // lexemeType
  // 

  const lexemeType::lexeme_type& lexemeType::
  lexeme () const
  {
    return this->lexeme_.get ();
  }

  lexemeType::lexeme_type& lexemeType::
  lexeme ()
  {
    return this->lexeme_.get ();
  }

  void lexemeType::
  lexeme (const lexeme_type& x)
  {
    this->lexeme_.set (x);
  }

  void lexemeType::
  lexeme (::std::auto_ptr< lexeme_type > x)
  {
    this->lexeme_.set (x);
  }

  const lexemeType::amount_type& lexemeType::
  amount () const
  {
    return this->amount_.get ();
  }

  lexemeType::amount_type& lexemeType::
  amount ()
  {
    return this->amount_.get ();
  }

  void lexemeType::
  amount (const amount_type& x)
  {
    this->amount_.set (x);
  }


  // headType
  // 

  const headType::ready_optional& headType::
  ready () const
  {
    return this->ready_;
  }

  headType::ready_optional& headType::
  ready ()
  {
    return this->ready_;
  }

  void headType::
  ready (const ready_type& x)
  {
    this->ready_.set (x);
  }

  void headType::
  ready (const ready_optional& x)
  {
    this->ready_ = x;
  }

  void headType::
  ready (::std::auto_ptr< ready_type > x)
  {
    this->ready_.set (x);
  }

  const headType::strokeStart_optional& headType::
  strokeStart () const
  {
    return this->strokeStart_;
  }

  headType::strokeStart_optional& headType::
  strokeStart ()
  {
    return this->strokeStart_;
  }

  void headType::
  strokeStart (const strokeStart_type& x)
  {
    this->strokeStart_.set (x);
  }

  void headType::
  strokeStart (const strokeStart_optional& x)
  {
    this->strokeStart_ = x;
  }

  void headType::
  strokeStart (::std::auto_ptr< strokeStart_type > x)
  {
    this->strokeStart_.set (x);
  }

  const headType::stroke_optional& headType::
  stroke () const
  {
    return this->stroke_;
  }

  headType::stroke_optional& headType::
  stroke ()
  {
    return this->stroke_;
  }

  void headType::
  stroke (const stroke_type& x)
  {
    this->stroke_.set (x);
  }

  void headType::
  stroke (const stroke_optional& x)
  {
    this->stroke_ = x;
  }

  void headType::
  stroke (::std::auto_ptr< stroke_type > x)
  {
    this->stroke_.set (x);
  }

  const headType::strokeEnd_optional& headType::
  strokeEnd () const
  {
    return this->strokeEnd_;
  }

  headType::strokeEnd_optional& headType::
  strokeEnd ()
  {
    return this->strokeEnd_;
  }

  void headType::
  strokeEnd (const strokeEnd_type& x)
  {
    this->strokeEnd_.set (x);
  }

  void headType::
  strokeEnd (const strokeEnd_optional& x)
  {
    this->strokeEnd_ = x;
  }

  void headType::
  strokeEnd (::std::auto_ptr< strokeEnd_type > x)
  {
    this->strokeEnd_.set (x);
  }

  const headType::relax_optional& headType::
  relax () const
  {
    return this->relax_;
  }

  headType::relax_optional& headType::
  relax ()
  {
    return this->relax_;
  }

  void headType::
  relax (const relax_type& x)
  {
    this->relax_.set (x);
  }

  void headType::
  relax (const relax_optional& x)
  {
    this->relax_ = x;
  }

  void headType::
  relax (::std::auto_ptr< relax_type > x)
  {
    this->relax_.set (x);
  }

  const headType::lexeme_optional& headType::
  lexeme () const
  {
    return this->lexeme_;
  }

  headType::lexeme_optional& headType::
  lexeme ()
  {
    return this->lexeme_;
  }

  void headType::
  lexeme (const lexeme_type& x)
  {
    this->lexeme_.set (x);
  }

  void headType::
  lexeme (const lexeme_optional& x)
  {
    this->lexeme_ = x;
  }

  void headType::
  lexeme (::std::auto_ptr< lexeme_type > x)
  {
    this->lexeme_.set (x);
  }

  const headType::repetition_optional& headType::
  repetition () const
  {
    return this->repetition_;
  }

  headType::repetition_optional& headType::
  repetition ()
  {
    return this->repetition_;
  }

  void headType::
  repetition (const repetition_type& x)
  {
    this->repetition_.set (x);
  }

  void headType::
  repetition (const repetition_optional& x)
  {
    this->repetition_ = x;
  }

  const headType::amount_optional& headType::
  amount () const
  {
    return this->amount_;
  }

  headType::amount_optional& headType::
  amount ()
  {
    return this->amount_;
  }

  void headType::
  amount (const amount_type& x)
  {
    this->amount_.set (x);
  }

  void headType::
  amount (const amount_optional& x)
  {
    this->amount_ = x;
  }

  const headType::target_optional& headType::
  target () const
  {
    return this->target_;
  }

  headType::target_optional& headType::
  target ()
  {
    return this->target_;
  }

  void headType::
  target (const target_type& x)
  {
    this->target_.set (x);
  }

  void headType::
  target (const target_optional& x)
  {
    this->target_ = x;
  }

  void headType::
  target (::std::auto_ptr< target_type > x)
  {
    this->target_.set (x);
  }


  // stanceType
  // 

  const stanceType::type_optional& stanceType::
  type () const
  {
    return this->type_;
  }

  stanceType::type_optional& stanceType::
  type ()
  {
    return this->type_;
  }

  void stanceType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void stanceType::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void stanceType::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // poseType
  // 

  const poseType::type_optional& poseType::
  type () const
  {
    return this->type_;
  }

  poseType::type_optional& poseType::
  type ()
  {
    return this->type_;
  }

  void poseType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void poseType::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void poseType::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const poseType::lexeme_optional& poseType::
  lexeme () const
  {
    return this->lexeme_;
  }

  poseType::lexeme_optional& poseType::
  lexeme ()
  {
    return this->lexeme_;
  }

  void poseType::
  lexeme (const lexeme_type& x)
  {
    this->lexeme_.set (x);
  }

  void poseType::
  lexeme (const lexeme_optional& x)
  {
    this->lexeme_ = x;
  }

  void poseType::
  lexeme (::std::auto_ptr< lexeme_type > x)
  {
    this->lexeme_.set (x);
  }


  // bml
  // 

  const bml::required_sequence& bml::
  required () const
  {
    return this->required_;
  }

  bml::required_sequence& bml::
  required ()
  {
    return this->required_;
  }

  void bml::
  required (const required_sequence& s)
  {
    this->required_ = s;
  }

  const bml::constraint_sequence& bml::
  constraint () const
  {
    return this->constraint_;
  }

  bml::constraint_sequence& bml::
  constraint ()
  {
    return this->constraint_;
  }

  void bml::
  constraint (const constraint_sequence& s)
  {
    this->constraint_ = s;
  }

  const bml::gaze_sequence& bml::
  gaze () const
  {
    return this->gaze_;
  }

  bml::gaze_sequence& bml::
  gaze ()
  {
    return this->gaze_;
  }

  void bml::
  gaze (const gaze_sequence& s)
  {
    this->gaze_ = s;
  }

  const bml::wait_sequence& bml::
  wait () const
  {
    return this->wait_;
  }

  bml::wait_sequence& bml::
  wait ()
  {
    return this->wait_;
  }

  void bml::
  wait (const wait_sequence& s)
  {
    this->wait_ = s;
  }

  const bml::headOrientation_sequence& bml::
  headOrientation () const
  {
    return this->headOrientation_;
  }

  bml::headOrientation_sequence& bml::
  headOrientation ()
  {
    return this->headOrientation_;
  }

  void bml::
  headOrientation (const headOrientation_sequence& s)
  {
    this->headOrientation_ = s;
  }

  const bml::posture_sequence& bml::
  posture () const
  {
    return this->posture_;
  }

  bml::posture_sequence& bml::
  posture ()
  {
    return this->posture_;
  }

  void bml::
  posture (const posture_sequence& s)
  {
    this->posture_ = s;
  }

  const bml::postureShift_sequence& bml::
  postureShift () const
  {
    return this->postureShift_;
  }

  bml::postureShift_sequence& bml::
  postureShift ()
  {
    return this->postureShift_;
  }

  void bml::
  postureShift (const postureShift_sequence& s)
  {
    this->postureShift_ = s;
  }

  const bml::speech_sequence& bml::
  speech () const
  {
    return this->speech_;
  }

  bml::speech_sequence& bml::
  speech ()
  {
    return this->speech_;
  }

  void bml::
  speech (const speech_sequence& s)
  {
    this->speech_ = s;
  }

  const bml::gesture_sequence& bml::
  gesture () const
  {
    return this->gesture_;
  }

  bml::gesture_sequence& bml::
  gesture ()
  {
    return this->gesture_;
  }

  void bml::
  gesture (const gesture_sequence& s)
  {
    this->gesture_ = s;
  }

  const bml::pointing_sequence& bml::
  pointing () const
  {
    return this->pointing_;
  }

  bml::pointing_sequence& bml::
  pointing ()
  {
    return this->pointing_;
  }

  void bml::
  pointing (const pointing_sequence& s)
  {
    this->pointing_ = s;
  }

  const bml::face_sequence& bml::
  face () const
  {
    return this->face_;
  }

  bml::face_sequence& bml::
  face ()
  {
    return this->face_;
  }

  void bml::
  face (const face_sequence& s)
  {
    this->face_ = s;
  }

  const bml::faceLexeme_sequence& bml::
  faceLexeme () const
  {
    return this->faceLexeme_;
  }

  bml::faceLexeme_sequence& bml::
  faceLexeme ()
  {
    return this->faceLexeme_;
  }

  void bml::
  faceLexeme (const faceLexeme_sequence& s)
  {
    this->faceLexeme_ = s;
  }

  const bml::locomotion_sequence& bml::
  locomotion () const
  {
    return this->locomotion_;
  }

  bml::locomotion_sequence& bml::
  locomotion ()
  {
    return this->locomotion_;
  }

  void bml::
  locomotion (const locomotion_sequence& s)
  {
    this->locomotion_ = s;
  }

  const bml::head_sequence& bml::
  head () const
  {
    return this->head_;
  }

  bml::head_sequence& bml::
  head ()
  {
    return this->head_;
  }

  void bml::
  head (const head_sequence& s)
  {
    this->head_ = s;
  }

  const bml::headDirectionShift_sequence& bml::
  headDirectionShift () const
  {
    return this->headDirectionShift_;
  }

  bml::headDirectionShift_sequence& bml::
  headDirectionShift ()
  {
    return this->headDirectionShift_;
  }

  void bml::
  headDirectionShift (const headDirectionShift_sequence& s)
  {
    this->headDirectionShift_ = s;
  }

  const bml::id_type& bml::
  id () const
  {
    return this->id_.get ();
  }

  bml::id_type& bml::
  id ()
  {
    return this->id_.get ();
  }

  void bml::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void bml::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const bml::characterId_optional& bml::
  characterId () const
  {
    return this->characterId_;
  }

  bml::characterId_optional& bml::
  characterId ()
  {
    return this->characterId_;
  }

  void bml::
  characterId (const characterId_type& x)
  {
    this->characterId_.set (x);
  }

  void bml::
  characterId (const characterId_optional& x)
  {
    this->characterId_ = x;
  }

  void bml::
  characterId (::std::auto_ptr< characterId_type > x)
  {
    this->characterId_.set (x);
  }

  const bml::composition_type& bml::
  composition () const
  {
    return this->composition_.get ();
  }

  bml::composition_type& bml::
  composition ()
  {
    return this->composition_.get ();
  }

  void bml::
  composition (const composition_type& x)
  {
    this->composition_.set (x);
  }

  void bml::
  composition (::std::auto_ptr< composition_type > x)
  {
    this->composition_.set (x);
  }

  const bml::composition_type& bml::
  composition_default_value ()
  {
    return composition_default_value_;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace bml
{
  // requiredType
  //

  requiredType::
  requiredType ()
  : ::xml_schema::type (),
    constraint_ (::xml_schema::flags (), this),
    gaze_ (::xml_schema::flags (), this),
    wait_ (::xml_schema::flags (), this),
    headOrientation_ (::xml_schema::flags (), this),
    posture_ (::xml_schema::flags (), this),
    postureShift_ (::xml_schema::flags (), this),
    speech_ (::xml_schema::flags (), this),
    gesture_ (::xml_schema::flags (), this),
    pointing_ (::xml_schema::flags (), this),
    face_ (::xml_schema::flags (), this),
    faceLexeme_ (::xml_schema::flags (), this),
    locomotion_ (::xml_schema::flags (), this),
    head_ (::xml_schema::flags (), this),
    headDirectionShift_ (::xml_schema::flags (), this)
  {
  }

  requiredType::
  requiredType (const requiredType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    constraint_ (x.constraint_, f, this),
    gaze_ (x.gaze_, f, this),
    wait_ (x.wait_, f, this),
    headOrientation_ (x.headOrientation_, f, this),
    posture_ (x.posture_, f, this),
    postureShift_ (x.postureShift_, f, this),
    speech_ (x.speech_, f, this),
    gesture_ (x.gesture_, f, this),
    pointing_ (x.pointing_, f, this),
    face_ (x.face_, f, this),
    faceLexeme_ (x.faceLexeme_, f, this),
    locomotion_ (x.locomotion_, f, this),
    head_ (x.head_, f, this),
    headDirectionShift_ (x.headDirectionShift_, f, this)
  {
  }

  requiredType::
  requiredType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    constraint_ (f, this),
    gaze_ (f, this),
    wait_ (f, this),
    headOrientation_ (f, this),
    posture_ (f, this),
    postureShift_ (f, this),
    speech_ (f, this),
    gesture_ (f, this),
    pointing_ (f, this),
    face_ (f, this),
    faceLexeme_ (f, this),
    locomotion_ (f, this),
    head_ (f, this),
    headDirectionShift_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void requiredType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // constraint
      //
      if (n.name () == "constraint" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< constraint_type > r (
          constraint_traits::create (i, f, this));

        this->constraint_.push_back (r);
        continue;
      }

      // gaze
      //
      if (n.name () == "gaze" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< gaze_type > r (
          gaze_traits::create (i, f, this));

        this->gaze_.push_back (r);
        continue;
      }

      // wait
      //
      if (n.name () == "wait" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< wait_type > r (
          wait_traits::create (i, f, this));

        this->wait_.push_back (r);
        continue;
      }

      // headOrientation
      //
      if (n.name () == "headOrientation" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< headOrientation_type > r (
          headOrientation_traits::create (i, f, this));

        this->headOrientation_.push_back (r);
        continue;
      }

      // posture
      //
      if (n.name () == "posture" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< posture_type > r (
          posture_traits::create (i, f, this));

        this->posture_.push_back (r);
        continue;
      }

      // postureShift
      //
      if (n.name () == "postureShift" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< postureShift_type > r (
          postureShift_traits::create (i, f, this));

        this->postureShift_.push_back (r);
        continue;
      }

      // speech
      //
      if (n.name () == "speech" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< speech_type > r (
          speech_traits::create (i, f, this));

        this->speech_.push_back (r);
        continue;
      }

      // gesture
      //
      if (n.name () == "gesture" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< gesture_type > r (
          gesture_traits::create (i, f, this));

        this->gesture_.push_back (r);
        continue;
      }

      // pointing
      //
      if (n.name () == "pointing" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< pointing_type > r (
          pointing_traits::create (i, f, this));

        this->pointing_.push_back (r);
        continue;
      }

      // face
      //
      if (n.name () == "face" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< face_type > r (
          face_traits::create (i, f, this));

        this->face_.push_back (r);
        continue;
      }

      // faceLexeme
      //
      if (n.name () == "faceLexeme" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< faceLexeme_type > r (
          faceLexeme_traits::create (i, f, this));

        this->faceLexeme_.push_back (r);
        continue;
      }

      // locomotion
      //
      if (n.name () == "locomotion" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< locomotion_type > r (
          locomotion_traits::create (i, f, this));

        this->locomotion_.push_back (r);
        continue;
      }

      // head
      //
      if (n.name () == "head" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< head_type > r (
          head_traits::create (i, f, this));

        this->head_.push_back (r);
        continue;
      }

      // headDirectionShift
      //
      if (n.name () == "headDirectionShift" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< headDirectionShift_type > r (
          headDirectionShift_traits::create (i, f, this));

        this->headDirectionShift_.push_back (r);
        continue;
      }

      break;
    }
  }

  requiredType* requiredType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class requiredType (*this, f, c);
  }

  requiredType::
  ~requiredType ()
  {
  }

  // behaviorType
  //

  behaviorType::
  behaviorType (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    start_ (::xml_schema::flags (), this),
    end_ (::xml_schema::flags (), this)
  {
  }

  behaviorType::
  behaviorType (const behaviorType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    start_ (x.start_, f, this),
    end_ (x.end_, f, this)
  {
  }

  behaviorType::
  behaviorType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    start_ (f, this),
    end_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void behaviorType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "start" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< start_type > r (
          start_traits::create (i, f, this));

        this->start_.set (r);
        continue;
      }

      if (n.name () == "end" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< end_type > r (
          end_traits::create (i, f, this));

        this->end_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  behaviorType* behaviorType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class behaviorType (*this, f, c);
  }

  behaviorType::
  ~behaviorType ()
  {
  }

  // constraintType
  //

  constraintType::
  constraintType ()
  : ::xml_schema::type (),
    synchronize_ (::xml_schema::flags (), this),
    before_ (::xml_schema::flags (), this),
    after_ (::xml_schema::flags (), this)
  {
  }

  constraintType::
  constraintType (const constraintType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    synchronize_ (x.synchronize_, f, this),
    before_ (x.before_, f, this),
    after_ (x.after_, f, this)
  {
  }

  constraintType::
  constraintType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    synchronize_ (f, this),
    before_ (f, this),
    after_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void constraintType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // synchronize
      //
      if (n.name () == "synchronize" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< synchronize_type > r (
          synchronize_traits::create (i, f, this));

        if (!this->synchronize_)
        {
          this->synchronize_.set (r);
          continue;
        }
      }

      // before
      //
      if (n.name () == "before" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< before_type > r (
          before_traits::create (i, f, this));

        if (!this->before_)
        {
          this->before_.set (r);
          continue;
        }
      }

      // after
      //
      if (n.name () == "after" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< after_type > r (
          after_traits::create (i, f, this));

        if (!this->after_)
        {
          this->after_.set (r);
          continue;
        }
      }

      break;
    }
  }

  constraintType* constraintType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class constraintType (*this, f, c);
  }

  constraintType::
  ~constraintType ()
  {
  }

  // synchronizeType
  //

  synchronizeType::
  synchronizeType ()
  : ::xml_schema::type (),
    sync_ (::xml_schema::flags (), this)
  {
  }

  synchronizeType::
  synchronizeType (const synchronizeType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sync_ (x.sync_, f, this)
  {
  }

  synchronizeType::
  synchronizeType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sync_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void synchronizeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sync
      //
      if (n.name () == "sync" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< sync_type > r (
          sync_traits::create (i, f, this));

        this->sync_.push_back (r);
        continue;
      }

      break;
    }
  }

  synchronizeType* synchronizeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class synchronizeType (*this, f, c);
  }

  synchronizeType::
  ~synchronizeType ()
  {
  }

  // beforeType
  //

  beforeType::
  beforeType ()
  : ::bml::synchronizeType (),
    ref_ (::xml_schema::flags (), this)
  {
  }

  beforeType::
  beforeType (const beforeType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::bml::synchronizeType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  beforeType::
  beforeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::bml::synchronizeType (e, f | ::xml_schema::flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void beforeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::synchronizeType::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }
  }

  beforeType* beforeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class beforeType (*this, f, c);
  }

  beforeType::
  ~beforeType ()
  {
  }

  // afterType
  //

  afterType::
  afterType ()
  : ::bml::synchronizeType (),
    ref_ (::xml_schema::flags (), this)
  {
  }

  afterType::
  afterType (const afterType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::bml::synchronizeType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  afterType::
  afterType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::bml::synchronizeType (e, f | ::xml_schema::flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void afterType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::synchronizeType::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }
  }

  afterType* afterType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class afterType (*this, f, c);
  }

  afterType::
  ~afterType ()
  {
  }

  // syncRefType
  //

  syncRefType::
  syncRefType ()
  : ::xml_schema::type (),
    ref_ (::xml_schema::flags (), this)
  {
  }

  syncRefType::
  syncRefType (const syncRefType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  syncRefType::
  syncRefType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void syncRefType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }
  }

  syncRefType* syncRefType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class syncRefType (*this, f, c);
  }

  syncRefType::
  ~syncRefType ()
  {
  }

  // waitType
  //

  waitType::
  waitType (const id_type& id)
  : ::bml::behaviorType (id),
    duration_ (::xml_schema::flags (), this)
  {
  }

  waitType::
  waitType (const waitType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    duration_ (x.duration_, f, this)
  {
  }

  waitType::
  waitType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    duration_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void waitType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }
    }
  }

  waitType* waitType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class waitType (*this, f, c);
  }

  waitType::
  ~waitType ()
  {
  }

  // gazeType
  //

  gazeType::
  gazeType (const id_type& id)
  : ::bml::behaviorType (id),
    target_ (::xml_schema::flags (), this),
    influence_ (::xml_schema::flags (), this),
    ready_ (::xml_schema::flags (), this),
    relax_ (::xml_schema::flags (), this),
    offsetAngle_ (::xml_schema::flags (), this),
    offsetDirection_ (::xml_schema::flags (), this)
  {
  }

  gazeType::
  gazeType (const gazeType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    target_ (x.target_, f, this),
    influence_ (x.influence_, f, this),
    ready_ (x.ready_, f, this),
    relax_ (x.relax_, f, this),
    offsetAngle_ (x.offsetAngle_, f, this),
    offsetDirection_ (x.offsetDirection_, f, this)
  {
  }

  gazeType::
  gazeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    target_ (f, this),
    influence_ (f, this),
    ready_ (f, this),
    relax_ (f, this),
    offsetAngle_ (f, this),
    offsetDirection_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void gazeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "target" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< target_type > r (
          target_traits::create (i, f, this));

        this->target_.set (r);
        continue;
      }

      if (n.name () == "influence" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< influence_type > r (
          influence_traits::create (i, f, this));

        this->influence_.set (r);
        continue;
      }

      if (n.name () == "ready" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ready_type > r (
          ready_traits::create (i, f, this));

        this->ready_.set (r);
        continue;
      }

      if (n.name () == "relax" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< relax_type > r (
          relax_traits::create (i, f, this));

        this->relax_.set (r);
        continue;
      }

      if (n.name () == "offsetAngle" && n.namespace_ ().empty ())
      {
        this->offsetAngle_.set (offsetAngle_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "offsetDirection" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< offsetDirection_type > r (
          offsetDirection_traits::create (i, f, this));

        this->offsetDirection_.set (r);
        continue;
      }
    }
  }

  gazeType* gazeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class gazeType (*this, f, c);
  }

  gazeType::
  ~gazeType ()
  {
  }

  // gestureType
  //

  gestureType::
  gestureType (const id_type& id)
  : ::bml::behaviorType (id),
    lexeme_ (::xml_schema::flags (), this),
    mode_ (::xml_schema::flags (), this),
    strokeStart_ (::xml_schema::flags (), this),
    stroke_ (::xml_schema::flags (), this),
    strokeEnd_ (::xml_schema::flags (), this),
    relax_ (::xml_schema::flags (), this),
    ready_ (::xml_schema::flags (), this)
  {
  }

  gestureType::
  gestureType (const gestureType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    lexeme_ (x.lexeme_, f, this),
    mode_ (x.mode_, f, this),
    strokeStart_ (x.strokeStart_, f, this),
    stroke_ (x.stroke_, f, this),
    strokeEnd_ (x.strokeEnd_, f, this),
    relax_ (x.relax_, f, this),
    ready_ (x.ready_, f, this)
  {
  }

  gestureType::
  gestureType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    lexeme_ (f, this),
    mode_ (f, this),
    strokeStart_ (f, this),
    stroke_ (f, this),
    strokeEnd_ (f, this),
    relax_ (f, this),
    ready_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void gestureType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lexeme" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lexeme_type > r (
          lexeme_traits::create (i, f, this));

        this->lexeme_.set (r);
        continue;
      }

      if (n.name () == "mode" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< mode_type > r (
          mode_traits::create (i, f, this));

        this->mode_.set (r);
        continue;
      }

      if (n.name () == "strokeStart" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< strokeStart_type > r (
          strokeStart_traits::create (i, f, this));

        this->strokeStart_.set (r);
        continue;
      }

      if (n.name () == "stroke" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< stroke_type > r (
          stroke_traits::create (i, f, this));

        this->stroke_.set (r);
        continue;
      }

      if (n.name () == "strokeEnd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< strokeEnd_type > r (
          strokeEnd_traits::create (i, f, this));

        this->strokeEnd_.set (r);
        continue;
      }

      if (n.name () == "relax" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< relax_type > r (
          relax_traits::create (i, f, this));

        this->relax_.set (r);
        continue;
      }

      if (n.name () == "ready" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ready_type > r (
          ready_traits::create (i, f, this));

        this->ready_.set (r);
        continue;
      }
    }
  }

  gestureType* gestureType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class gestureType (*this, f, c);
  }

  gestureType::
  ~gestureType ()
  {
  }

  // syncType
  //

  syncType::
  syncType ()
  : ::xml_schema::type (),
    id_ (::xml_schema::flags (), this)
  {
  }

  syncType::
  syncType (const syncType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  syncType::
  syncType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void syncType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }
  }

  syncType* syncType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class syncType (*this, f, c);
  }

  syncType::
  ~syncType ()
  {
  }

  // textType
  //

  textType::
  textType ()
  : ::xml_schema::type (),
    sync_ (::xml_schema::flags (), this)
  {
  }

  textType::
  textType (const textType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sync_ (x.sync_, f, this)
  {
  }

  textType::
  textType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sync_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void textType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sync
      //
      if (n.name () == "sync" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< sync_type > r (
          sync_traits::create (i, f, this));

        this->sync_.push_back (r);
        continue;
      }

      break;
    }
  }

  textType* textType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class textType (*this, f, c);
  }

  textType::
  ~textType ()
  {
  }

  // speech
  //

  speech::
  speech (const id_type& id)
  : ::bml::behaviorType (id),
    text_ (::xml_schema::flags (), this)
  {
  }

  speech::
  speech (const speech& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    text_ (x.text_, f, this)
  {
  }

  speech::
  speech (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    text_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void speech::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // text
      //
      if (n.name () == "text" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< text_type > r (
          text_traits::create (i, f, this));

        this->text_.push_back (r);
        continue;
      }

      break;
    }
  }

  speech* speech::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class speech (*this, f, c);
  }

  speech::
  ~speech ()
  {
  }

  // postureType
  //

  postureType::
  postureType (const id_type& id)
  : ::bml::behaviorType (id),
    pose_ (::xml_schema::flags (), this),
    stance_ (::xml_schema::flags (), this),
    ready_ (::xml_schema::flags (), this),
    relax_ (::xml_schema::flags (), this)
  {
  }

  postureType::
  postureType (const postureType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    pose_ (x.pose_, f, this),
    stance_ (x.stance_, f, this),
    ready_ (x.ready_, f, this),
    relax_ (x.relax_, f, this)
  {
  }

  postureType::
  postureType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    pose_ (f, this),
    stance_ (f, this),
    ready_ (f, this),
    relax_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void postureType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pose
      //
      if (n.name () == "pose" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< pose_type > r (
          pose_traits::create (i, f, this));

        this->pose_.push_back (r);
        continue;
      }

      // stance
      //
      if (n.name () == "stance" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< stance_type > r (
          stance_traits::create (i, f, this));

        if (!this->stance_)
        {
          this->stance_.set (r);
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ready" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ready_type > r (
          ready_traits::create (i, f, this));

        this->ready_.set (r);
        continue;
      }

      if (n.name () == "relax" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< relax_type > r (
          relax_traits::create (i, f, this));

        this->relax_.set (r);
        continue;
      }
    }
  }

  postureType* postureType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class postureType (*this, f, c);
  }

  postureType::
  ~postureType ()
  {
  }

  // faceAbstractType
  //

  faceAbstractType::
  faceAbstractType (const id_type& id)
  : ::bml::behaviorType (id),
    amount_ (amount_default_value (), ::xml_schema::flags (), this),
    attackPeak_ (::xml_schema::flags (), this),
    relax_ (::xml_schema::flags (), this)
  {
  }

  faceAbstractType::
  faceAbstractType (const faceAbstractType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    amount_ (x.amount_, f, this),
    attackPeak_ (x.attackPeak_, f, this),
    relax_ (x.relax_, f, this)
  {
  }

  faceAbstractType::
  faceAbstractType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    amount_ (f, this),
    attackPeak_ (f, this),
    relax_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void faceAbstractType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "amount" && n.namespace_ ().empty ())
      {
        this->amount_.set (amount_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "attackPeak" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< attackPeak_type > r (
          attackPeak_traits::create (i, f, this));

        this->attackPeak_.set (r);
        continue;
      }

      if (n.name () == "relax" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< relax_type > r (
          relax_traits::create (i, f, this));

        this->relax_.set (r);
        continue;
      }
    }

    if (!amount_.present ())
    {
      this->amount_.set (amount_default_value ());
    }
  }

  faceAbstractType* faceAbstractType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class faceAbstractType (*this, f, c);
  }

  faceAbstractType::
  ~faceAbstractType ()
  {
  }

  // faceLexemeType
  //

  faceLexemeType::
  faceLexemeType (const id_type& id,
                  const lexeme_type& lexeme)
  : ::bml::faceAbstractType (id),
    lexeme_ (lexeme, ::xml_schema::flags (), this)
  {
  }

  faceLexemeType::
  faceLexemeType (const faceLexemeType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::bml::faceAbstractType (x, f, c),
    lexeme_ (x.lexeme_, f, this)
  {
  }

  faceLexemeType::
  faceLexemeType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::bml::faceAbstractType (e, f | ::xml_schema::flags::base, c),
    lexeme_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void faceLexemeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::faceAbstractType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lexeme" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lexeme_type > r (
          lexeme_traits::create (i, f, this));

        this->lexeme_.set (r);
        continue;
      }
    }

    if (!lexeme_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lexeme",
        "");
    }
  }

  faceLexemeType* faceLexemeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class faceLexemeType (*this, f, c);
  }

  faceLexemeType::
  ~faceLexemeType ()
  {
  }

  // syncBlock
  //

  syncBlock::
  syncBlock ()
  : ::xml_schema::type (),
    sync_ (::xml_schema::flags (), this),
    ref_ (::xml_schema::flags (), this)
  {
  }

  syncBlock::
  syncBlock (const syncBlock& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sync_ (x.sync_, f, this),
    ref_ (x.ref_, f, this)
  {
  }

  syncBlock::
  syncBlock (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sync_ (f, this),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void syncBlock::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sync
      //
      if (n.name () == "sync" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< sync_type > r (
          sync_traits::create (i, f, this));

        this->sync_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref_type > r (
          ref_traits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }
  }

  syncBlock* syncBlock::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class syncBlock (*this, f, c);
  }

  syncBlock::
  ~syncBlock ()
  {
  }

  // targetID
  //

  targetID::
  targetID ()
  : ::xml_schema::string ()
  {
  }

  targetID::
  targetID (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  targetID::
  targetID (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  targetID::
  targetID (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  targetID::
  targetID (const targetID& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  targetID::
  targetID (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  targetID::
  targetID (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  targetID::
  targetID (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  targetID* targetID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class targetID (*this, f, c);
  }

  targetID::
  ~targetID ()
  {
  }

  // id
  //

  id::
  id ()
  : ::xml_schema::string ()
  {
  }

  id::
  id (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  id::
  id (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  id::
  id (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  id::
  id (const id& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  id::
  id (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  id::
  id (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  id::
  id (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  id* id::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class id (*this, f, c);
  }

  id::
  ~id ()
  {
  }

  // openSetItem
  //

  openSetItem::
  openSetItem (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
  {
  }

  openSetItem::
  openSetItem (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
  {
  }

  openSetItem::
  openSetItem (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
  {
  }

  openSetItem* openSetItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class openSetItem (*this, f, c);
  }

  openSetItem::
  ~openSetItem ()
  {
  }

  // closedSetItem
  //

  closedSetItem::
  closedSetItem (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
  {
  }

  closedSetItem::
  closedSetItem (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
  {
  }

  closedSetItem::
  closedSetItem (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
  {
  }

  closedSetItem* closedSetItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class closedSetItem (*this, f, c);
  }

  closedSetItem::
  ~closedSetItem ()
  {
  }

  // pointingType
  //

  pointingType::
  pointingType (const id_type& id)
  : ::bml::behaviorType (id),
    target_ (::xml_schema::flags (), this),
    mode_ (::xml_schema::flags (), this),
    ready_ (::xml_schema::flags (), this),
    strokeStart_ (::xml_schema::flags (), this),
    stroke_ (::xml_schema::flags (), this),
    strokeEnd_ (::xml_schema::flags (), this),
    relax_ (::xml_schema::flags (), this)
  {
  }

  pointingType::
  pointingType (const pointingType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    target_ (x.target_, f, this),
    mode_ (x.mode_, f, this),
    ready_ (x.ready_, f, this),
    strokeStart_ (x.strokeStart_, f, this),
    stroke_ (x.stroke_, f, this),
    strokeEnd_ (x.strokeEnd_, f, this),
    relax_ (x.relax_, f, this)
  {
  }

  pointingType::
  pointingType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    target_ (f, this),
    mode_ (f, this),
    ready_ (f, this),
    strokeStart_ (f, this),
    stroke_ (f, this),
    strokeEnd_ (f, this),
    relax_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void pointingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "target" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< target_type > r (
          target_traits::create (i, f, this));

        this->target_.set (r);
        continue;
      }

      if (n.name () == "mode" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< mode_type > r (
          mode_traits::create (i, f, this));

        this->mode_.set (r);
        continue;
      }

      if (n.name () == "ready" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ready_type > r (
          ready_traits::create (i, f, this));

        this->ready_.set (r);
        continue;
      }

      if (n.name () == "strokeStart" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< strokeStart_type > r (
          strokeStart_traits::create (i, f, this));

        this->strokeStart_.set (r);
        continue;
      }

      if (n.name () == "stroke" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< stroke_type > r (
          stroke_traits::create (i, f, this));

        this->stroke_.set (r);
        continue;
      }

      if (n.name () == "strokeEnd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< strokeEnd_type > r (
          strokeEnd_traits::create (i, f, this));

        this->strokeEnd_.set (r);
        continue;
      }

      if (n.name () == "relax" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< relax_type > r (
          relax_traits::create (i, f, this));

        this->relax_.set (r);
        continue;
      }
    }
  }

  pointingType* pointingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class pointingType (*this, f, c);
  }

  pointingType::
  ~pointingType ()
  {
  }

  // locomotionType
  //

  locomotionType::
  locomotionType (const id_type& id)
  : ::bml::behaviorType (id),
    manner_ (::xml_schema::flags (), this),
    target_ (::xml_schema::flags (), this)
  {
  }

  locomotionType::
  locomotionType (const locomotionType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    manner_ (x.manner_, f, this),
    target_ (x.target_, f, this)
  {
  }

  locomotionType::
  locomotionType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    manner_ (f, this),
    target_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void locomotionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "manner" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< manner_type > r (
          manner_traits::create (i, f, this));

        this->manner_.set (r);
        continue;
      }

      if (n.name () == "target" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< target_type > r (
          target_traits::create (i, f, this));

        this->target_.set (r);
        continue;
      }
    }
  }

  locomotionType* locomotionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class locomotionType (*this, f, c);
  }

  locomotionType::
  ~locomotionType ()
  {
  }

  // headDirectionShiftType
  //

  headDirectionShiftType::
  headDirectionShiftType (const id_type& id,
                          const target_type& target)
  : ::bml::behaviorType (id),
    target_ (target, ::xml_schema::flags (), this)
  {
  }

  headDirectionShiftType::
  headDirectionShiftType (const headDirectionShiftType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    target_ (x.target_, f, this)
  {
  }

  headDirectionShiftType::
  headDirectionShiftType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    target_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void headDirectionShiftType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "target" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< target_type > r (
          target_traits::create (i, f, this));

        this->target_.set (r);
        continue;
      }
    }

    if (!target_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "target",
        "");
    }
  }

  headDirectionShiftType* headDirectionShiftType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class headDirectionShiftType (*this, f, c);
  }

  headDirectionShiftType::
  ~headDirectionShiftType ()
  {
  }

  // faceFacs
  //

  static faceFacs::side_type
  _xsd_faceFacsside_default_value_init ()
  {
    faceFacs::side_type r;

    {
      ::xml_schema::string tmp ("BOTH");
      r.push_back (tmp);
    }

    return r;
  };

  const faceFacs::side_type faceFacs::side_default_value_ (
    _xsd_faceFacsside_default_value_init ());

  faceFacs::
  faceFacs (const id_type& id,
            const au_type& au)
  : ::bml::faceAbstractType (id),
    au_ (au, ::xml_schema::flags (), this),
    side_ (side_default_value (), ::xml_schema::flags (), this)
  {
  }

  faceFacs::
  faceFacs (const faceFacs& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::faceAbstractType (x, f, c),
    au_ (x.au_, f, this),
    side_ (x.side_, f, this)
  {
  }

  faceFacs::
  faceFacs (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::faceAbstractType (e, f | ::xml_schema::flags::base, c),
    au_ (f, this),
    side_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void faceFacs::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::faceAbstractType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "au" && n.namespace_ ().empty ())
      {
        this->au_.set (au_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "side" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< side_type > r (
          side_traits::create (i, f, this));

        this->side_.set (r);
        continue;
      }
    }

    if (!au_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "au",
        "");
    }

    if (!side_.present ())
    {
      this->side_.set (side_default_value ());
    }
  }

  faceFacs* faceFacs::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class faceFacs (*this, f, c);
  }

  faceFacs::
  ~faceFacs ()
  {
  }

  // faceType
  //

  faceType::
  faceType (const id_type& id,
            const lexeme_type& lexeme)
  : ::bml::faceAbstractType (id),
    lexeme_ (lexeme, ::xml_schema::flags (), this)
  {
  }

  faceType::
  faceType (const id_type& id,
            ::std::auto_ptr< lexeme_type >& lexeme)
  : ::bml::faceAbstractType (id),
    lexeme_ (lexeme, ::xml_schema::flags (), this)
  {
  }

  faceType::
  faceType (const faceType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::faceAbstractType (x, f, c),
    lexeme_ (x.lexeme_, f, this)
  {
  }

  faceType::
  faceType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::faceAbstractType (e, f | ::xml_schema::flags::base, c),
    lexeme_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void faceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::faceAbstractType::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lexeme
      //
      if (n.name () == "lexeme" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< lexeme_type > r (
          lexeme_traits::create (i, f, this));

        if (!lexeme_.present ())
        {
          this->lexeme_.set (r);
          continue;
        }
      }

      break;
    }

    if (!lexeme_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "lexeme",
        "bml");
    }
  }

  faceType* faceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class faceType (*this, f, c);
  }

  faceType::
  ~faceType ()
  {
  }

  // faceShiftType
  //

  faceShiftType::
  faceShiftType (const id_type& id,
                 const lexeme_type& lexeme)
  : ::bml::faceAbstractType (id),
    lexeme_ (lexeme, ::xml_schema::flags (), this)
  {
  }

  faceShiftType::
  faceShiftType (const id_type& id,
                 ::std::auto_ptr< lexeme_type >& lexeme)
  : ::bml::faceAbstractType (id),
    lexeme_ (lexeme, ::xml_schema::flags (), this)
  {
  }

  faceShiftType::
  faceShiftType (const faceShiftType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::bml::faceAbstractType (x, f, c),
    lexeme_ (x.lexeme_, f, this)
  {
  }

  faceShiftType::
  faceShiftType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::bml::faceAbstractType (e, f | ::xml_schema::flags::base, c),
    lexeme_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void faceShiftType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::faceAbstractType::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lexeme
      //
      if (n.name () == "lexeme" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< lexeme_type > r (
          lexeme_traits::create (i, f, this));

        if (!lexeme_.present ())
        {
          this->lexeme_.set (r);
          continue;
        }
      }

      break;
    }

    if (!lexeme_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "lexeme",
        "bml");
    }
  }

  faceShiftType* faceShiftType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class faceShiftType (*this, f, c);
  }

  faceShiftType::
  ~faceShiftType ()
  {
  }

  // lexemeType
  //

  lexemeType::
  lexemeType (const lexeme_type& lexeme,
              const amount_type& amount)
  : ::xml_schema::type (),
    lexeme_ (lexeme, ::xml_schema::flags (), this),
    amount_ (amount, ::xml_schema::flags (), this)
  {
  }

  lexemeType::
  lexemeType (const lexemeType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    lexeme_ (x.lexeme_, f, this),
    amount_ (x.amount_, f, this)
  {
  }

  lexemeType::
  lexemeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    lexeme_ (f, this),
    amount_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void lexemeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lexeme" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lexeme_type > r (
          lexeme_traits::create (i, f, this));

        this->lexeme_.set (r);
        continue;
      }

      if (n.name () == "amount" && n.namespace_ ().empty ())
      {
        this->amount_.set (amount_traits::create (i, f, this));
        continue;
      }
    }

    if (!lexeme_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lexeme",
        "");
    }

    if (!amount_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "amount",
        "");
    }
  }

  lexemeType* lexemeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class lexemeType (*this, f, c);
  }

  lexemeType::
  ~lexemeType ()
  {
  }

  // headType
  //

  headType::
  headType (const id_type& id)
  : ::bml::behaviorType (id),
    ready_ (::xml_schema::flags (), this),
    strokeStart_ (::xml_schema::flags (), this),
    stroke_ (::xml_schema::flags (), this),
    strokeEnd_ (::xml_schema::flags (), this),
    relax_ (::xml_schema::flags (), this),
    lexeme_ (::xml_schema::flags (), this),
    repetition_ (::xml_schema::flags (), this),
    amount_ (::xml_schema::flags (), this),
    target_ (::xml_schema::flags (), this)
  {
  }

  headType::
  headType (const headType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::behaviorType (x, f, c),
    ready_ (x.ready_, f, this),
    strokeStart_ (x.strokeStart_, f, this),
    stroke_ (x.stroke_, f, this),
    strokeEnd_ (x.strokeEnd_, f, this),
    relax_ (x.relax_, f, this),
    lexeme_ (x.lexeme_, f, this),
    repetition_ (x.repetition_, f, this),
    amount_ (x.amount_, f, this),
    target_ (x.target_, f, this)
  {
  }

  headType::
  headType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::bml::behaviorType (e, f | ::xml_schema::flags::base, c),
    ready_ (f, this),
    strokeStart_ (f, this),
    stroke_ (f, this),
    strokeEnd_ (f, this),
    relax_ (f, this),
    lexeme_ (f, this),
    repetition_ (f, this),
    amount_ (f, this),
    target_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void headType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::bml::behaviorType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ready" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ready_type > r (
          ready_traits::create (i, f, this));

        this->ready_.set (r);
        continue;
      }

      if (n.name () == "strokeStart" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< strokeStart_type > r (
          strokeStart_traits::create (i, f, this));

        this->strokeStart_.set (r);
        continue;
      }

      if (n.name () == "stroke" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< stroke_type > r (
          stroke_traits::create (i, f, this));

        this->stroke_.set (r);
        continue;
      }

      if (n.name () == "strokeEnd" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< strokeEnd_type > r (
          strokeEnd_traits::create (i, f, this));

        this->strokeEnd_.set (r);
        continue;
      }

      if (n.name () == "relax" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< relax_type > r (
          relax_traits::create (i, f, this));

        this->relax_.set (r);
        continue;
      }

      if (n.name () == "lexeme" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lexeme_type > r (
          lexeme_traits::create (i, f, this));

        this->lexeme_.set (r);
        continue;
      }

      if (n.name () == "repetition" && n.namespace_ ().empty ())
      {
        this->repetition_.set (repetition_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "amount" && n.namespace_ ().empty ())
      {
        this->amount_.set (amount_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "target" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< target_type > r (
          target_traits::create (i, f, this));

        this->target_.set (r);
        continue;
      }
    }
  }

  headType* headType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class headType (*this, f, c);
  }

  headType::
  ~headType ()
  {
  }

  // stanceType
  //

  stanceType::
  stanceType ()
  : ::xml_schema::type (),
    type_ (::xml_schema::flags (), this)
  {
  }

  stanceType::
  stanceType (const stanceType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  stanceType::
  stanceType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void stanceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }
  }

  stanceType* stanceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stanceType (*this, f, c);
  }

  stanceType::
  ~stanceType ()
  {
  }

  // poseType
  //

  poseType::
  poseType ()
  : ::xml_schema::type (),
    type_ (::xml_schema::flags (), this),
    lexeme_ (::xml_schema::flags (), this)
  {
  }

  poseType::
  poseType (const poseType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    lexeme_ (x.lexeme_, f, this)
  {
  }

  poseType::
  poseType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    lexeme_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void poseType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "lexeme" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lexeme_type > r (
          lexeme_traits::create (i, f, this));

        this->lexeme_.set (r);
        continue;
      }
    }
  }

  poseType* poseType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class poseType (*this, f, c);
  }

  poseType::
  ~poseType ()
  {
  }

  // bml
  //

  static bml::composition_type
  _xsd_bmlcomposition_default_value_init ()
  {
    bml::composition_type r;

    {
      ::xml_schema::string tmp ("MERGE");
      r.push_back (tmp);
    }

    return r;
  };

  const bml::composition_type bml::composition_default_value_ (
    _xsd_bmlcomposition_default_value_init ());

  bml::
  bml (const id_type& id)
  : ::xml_schema::type (),
    required_ (::xml_schema::flags (), this),
    constraint_ (::xml_schema::flags (), this),
    gaze_ (::xml_schema::flags (), this),
    wait_ (::xml_schema::flags (), this),
    headOrientation_ (::xml_schema::flags (), this),
    posture_ (::xml_schema::flags (), this),
    postureShift_ (::xml_schema::flags (), this),
    speech_ (::xml_schema::flags (), this),
    gesture_ (::xml_schema::flags (), this),
    pointing_ (::xml_schema::flags (), this),
    face_ (::xml_schema::flags (), this),
    faceLexeme_ (::xml_schema::flags (), this),
    locomotion_ (::xml_schema::flags (), this),
    head_ (::xml_schema::flags (), this),
    headDirectionShift_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    characterId_ (::xml_schema::flags (), this),
    composition_ (composition_default_value (), ::xml_schema::flags (), this)
  {
  }

  bml::
  bml (const bml& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    required_ (x.required_, f, this),
    constraint_ (x.constraint_, f, this),
    gaze_ (x.gaze_, f, this),
    wait_ (x.wait_, f, this),
    headOrientation_ (x.headOrientation_, f, this),
    posture_ (x.posture_, f, this),
    postureShift_ (x.postureShift_, f, this),
    speech_ (x.speech_, f, this),
    gesture_ (x.gesture_, f, this),
    pointing_ (x.pointing_, f, this),
    face_ (x.face_, f, this),
    faceLexeme_ (x.faceLexeme_, f, this),
    locomotion_ (x.locomotion_, f, this),
    head_ (x.head_, f, this),
    headDirectionShift_ (x.headDirectionShift_, f, this),
    id_ (x.id_, f, this),
    characterId_ (x.characterId_, f, this),
    composition_ (x.composition_, f, this)
  {
  }

  bml::
  bml (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    required_ (f, this),
    constraint_ (f, this),
    gaze_ (f, this),
    wait_ (f, this),
    headOrientation_ (f, this),
    posture_ (f, this),
    postureShift_ (f, this),
    speech_ (f, this),
    gesture_ (f, this),
    pointing_ (f, this),
    face_ (f, this),
    faceLexeme_ (f, this),
    locomotion_ (f, this),
    head_ (f, this),
    headDirectionShift_ (f, this),
    id_ (f, this),
    characterId_ (f, this),
    composition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void bml::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // required
      //
      if (n.name () == "required" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< required_type > r (
          required_traits::create (i, f, this));

        this->required_.push_back (r);
        continue;
      }

      // constraint
      //
      if (n.name () == "constraint" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< constraint_type > r (
          constraint_traits::create (i, f, this));

        this->constraint_.push_back (r);
        continue;
      }

      // gaze
      //
      if (n.name () == "gaze" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< gaze_type > r (
          gaze_traits::create (i, f, this));

        this->gaze_.push_back (r);
        continue;
      }

      // wait
      //
      if (n.name () == "wait" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< wait_type > r (
          wait_traits::create (i, f, this));

        this->wait_.push_back (r);
        continue;
      }

      // headOrientation
      //
      if (n.name () == "headOrientation" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< headOrientation_type > r (
          headOrientation_traits::create (i, f, this));

        this->headOrientation_.push_back (r);
        continue;
      }

      // posture
      //
      if (n.name () == "posture" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< posture_type > r (
          posture_traits::create (i, f, this));

        this->posture_.push_back (r);
        continue;
      }

      // postureShift
      //
      if (n.name () == "postureShift" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< postureShift_type > r (
          postureShift_traits::create (i, f, this));

        this->postureShift_.push_back (r);
        continue;
      }

      // speech
      //
      if (n.name () == "speech" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< speech_type > r (
          speech_traits::create (i, f, this));

        this->speech_.push_back (r);
        continue;
      }

      // gesture
      //
      if (n.name () == "gesture" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< gesture_type > r (
          gesture_traits::create (i, f, this));

        this->gesture_.push_back (r);
        continue;
      }

      // pointing
      //
      if (n.name () == "pointing" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< pointing_type > r (
          pointing_traits::create (i, f, this));

        this->pointing_.push_back (r);
        continue;
      }

      // face
      //
      if (n.name () == "face" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< face_type > r (
          face_traits::create (i, f, this));

        this->face_.push_back (r);
        continue;
      }

      // faceLexeme
      //
      if (n.name () == "faceLexeme" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< faceLexeme_type > r (
          faceLexeme_traits::create (i, f, this));

        this->faceLexeme_.push_back (r);
        continue;
      }

      // locomotion
      //
      if (n.name () == "locomotion" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< locomotion_type > r (
          locomotion_traits::create (i, f, this));

        this->locomotion_.push_back (r);
        continue;
      }

      // head
      //
      if (n.name () == "head" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< head_type > r (
          head_traits::create (i, f, this));

        this->head_.push_back (r);
        continue;
      }

      // headDirectionShift
      //
      if (n.name () == "headDirectionShift" && n.namespace_ () == "bml")
      {
        ::std::auto_ptr< headDirectionShift_type > r (
          headDirectionShift_traits::create (i, f, this));

        this->headDirectionShift_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "characterId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< characterId_type > r (
          characterId_traits::create (i, f, this));

        this->characterId_.set (r);
        continue;
      }

      if (n.name () == "composition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< composition_type > r (
          composition_traits::create (i, f, this));

        this->composition_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!composition_.present ())
    {
      this->composition_.set (composition_default_value ());
    }
  }

  bml* bml::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bml (*this, f, c);
  }

  bml::
  ~bml ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace bml
{
  ::std::auto_ptr< ::bml::bml >
  bml_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::bml > r (
      ::bml::bml_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::bml > r (
      ::bml::bml_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::bml > r (
      ::bml::bml_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::bml_ (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::bml_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::bml_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::bml_ (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::bml_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::bml_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::bml > r (
      ::bml::bml_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::bml > r (
      ::bml::bml_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::bml > r (
      ::bml::bml_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::bml > r (
        ::bml::bml_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "bml" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::bml > r (
        ::xsd::cxx::tree::traits< ::bml::bml, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "bml",
      "bml");
  }

  ::std::auto_ptr< ::bml::bml >
  bml_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "bml" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::bml > r (
        ::xsd::cxx::tree::traits< ::bml::bml, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "bml",
      "bml");
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::posture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::posture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::posture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::posture (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::posture (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::posture (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::posture (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::posture (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::posture (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::posture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::posture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::posture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::postureType > r (
        ::bml::posture (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "posture" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::postureType > r (
        ::xsd::cxx::tree::traits< ::bml::postureType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "posture",
      "bml");
  }

  ::std::auto_ptr< ::bml::postureType >
  posture (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "posture" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::postureType > r (
        ::xsd::cxx::tree::traits< ::bml::postureType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "posture",
      "bml");
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::gestureType > r (
      ::bml::gesture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::gestureType > r (
      ::bml::gesture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::gestureType > r (
      ::bml::gesture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::gesture (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::gesture (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::gesture (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::gesture (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::gesture (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::gesture (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::gestureType > r (
      ::bml::gesture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::gestureType > r (
      ::bml::gesture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::gestureType > r (
      ::bml::gesture (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::gestureType > r (
        ::bml::gesture (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "gesture" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::gestureType > r (
        ::xsd::cxx::tree::traits< ::bml::gestureType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "gesture",
      "bml");
  }

  ::std::auto_ptr< ::bml::gestureType >
  gesture (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "gesture" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::gestureType > r (
        ::xsd::cxx::tree::traits< ::bml::gestureType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "gesture",
      "bml");
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::pointingType > r (
      ::bml::pointing (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::pointingType > r (
      ::bml::pointing (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::pointingType > r (
      ::bml::pointing (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::pointing (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::pointing (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::pointing (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::pointing (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::pointing (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::pointing (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::pointingType > r (
      ::bml::pointing (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::pointingType > r (
      ::bml::pointing (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::pointingType > r (
      ::bml::pointing (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::pointingType > r (
        ::bml::pointing (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "pointing" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::pointingType > r (
        ::xsd::cxx::tree::traits< ::bml::pointingType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "pointing",
      "bml");
  }

  ::std::auto_ptr< ::bml::pointingType >
  pointing (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "pointing" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::pointingType > r (
        ::xsd::cxx::tree::traits< ::bml::pointingType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "pointing",
      "bml");
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::locomotionType > r (
      ::bml::locomotion (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::locomotionType > r (
      ::bml::locomotion (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::locomotionType > r (
      ::bml::locomotion (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::locomotion (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::locomotion (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::locomotion (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::locomotion (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::locomotion (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::locomotion (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::locomotionType > r (
      ::bml::locomotion (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::locomotionType > r (
      ::bml::locomotion (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::locomotionType > r (
      ::bml::locomotion (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::locomotionType > r (
        ::bml::locomotion (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "locomotion" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::locomotionType > r (
        ::xsd::cxx::tree::traits< ::bml::locomotionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "locomotion",
      "bml");
  }

  ::std::auto_ptr< ::bml::locomotionType >
  locomotion (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "locomotion" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::locomotionType > r (
        ::xsd::cxx::tree::traits< ::bml::locomotionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "locomotion",
      "bml");
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::faceAbstractType > r (
      ::bml::faceAbstract (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceAbstractType > r (
      ::bml::faceAbstract (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceAbstractType > r (
      ::bml::faceAbstract (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceAbstract (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceAbstract (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceAbstract (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceAbstract (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceAbstract (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceAbstract (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::faceAbstractType > r (
      ::bml::faceAbstract (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceAbstractType > r (
      ::bml::faceAbstract (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceAbstractType > r (
      ::bml::faceAbstract (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::faceAbstractType > r (
        ::bml::faceAbstract (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "faceAbstract" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::faceAbstractType > r (
        ::xsd::cxx::tree::traits< ::bml::faceAbstractType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "faceAbstract",
      "bml");
  }

  ::std::auto_ptr< ::bml::faceAbstractType >
  faceAbstract (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "faceAbstract" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::faceAbstractType > r (
        ::xsd::cxx::tree::traits< ::bml::faceAbstractType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "faceAbstract",
      "bml");
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::gazeType > r (
      ::bml::gaze (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::gazeType > r (
      ::bml::gaze (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::gazeType > r (
      ::bml::gaze (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::gaze (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::gaze (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::gaze (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::gaze (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::gaze (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::gaze (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::gazeType > r (
      ::bml::gaze (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::gazeType > r (
      ::bml::gaze (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::gazeType > r (
      ::bml::gaze (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::gazeType > r (
        ::bml::gaze (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "gaze" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::gazeType > r (
        ::xsd::cxx::tree::traits< ::bml::gazeType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "gaze",
      "bml");
  }

  ::std::auto_ptr< ::bml::gazeType >
  gaze (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "gaze" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::gazeType > r (
        ::xsd::cxx::tree::traits< ::bml::gazeType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "gaze",
      "bml");
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::headDirectionShiftType > r (
      ::bml::headDirectionShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::headDirectionShiftType > r (
      ::bml::headDirectionShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::headDirectionShiftType > r (
      ::bml::headDirectionShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::headDirectionShift (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::headDirectionShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::headDirectionShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::headDirectionShift (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::headDirectionShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::headDirectionShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::headDirectionShiftType > r (
      ::bml::headDirectionShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::headDirectionShiftType > r (
      ::bml::headDirectionShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::headDirectionShiftType > r (
      ::bml::headDirectionShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::headDirectionShiftType > r (
        ::bml::headDirectionShift (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "headDirectionShift" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::headDirectionShiftType > r (
        ::xsd::cxx::tree::traits< ::bml::headDirectionShiftType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "headDirectionShift",
      "bml");
  }

  ::std::auto_ptr< ::bml::headDirectionShiftType >
  headDirectionShift (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "headDirectionShift" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::headDirectionShiftType > r (
        ::xsd::cxx::tree::traits< ::bml::headDirectionShiftType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "headDirectionShift",
      "bml");
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::faceLexemeType > r (
      ::bml::faceLexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceLexemeType > r (
      ::bml::faceLexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceLexemeType > r (
      ::bml::faceLexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceLexeme (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceLexeme (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceLexeme (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceLexeme (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceLexeme (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceLexeme (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::faceLexemeType > r (
      ::bml::faceLexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceLexemeType > r (
      ::bml::faceLexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceLexemeType > r (
      ::bml::faceLexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::faceLexemeType > r (
        ::bml::faceLexeme (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "faceLexeme" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::faceLexemeType > r (
        ::xsd::cxx::tree::traits< ::bml::faceLexemeType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "faceLexeme",
      "bml");
  }

  ::std::auto_ptr< ::bml::faceLexemeType >
  faceLexeme (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "faceLexeme" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::faceLexemeType > r (
        ::xsd::cxx::tree::traits< ::bml::faceLexemeType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "faceLexeme",
      "bml");
  }

  ::std::auto_ptr< ::bml::faceType >
  face (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::faceType > r (
      ::bml::face (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceType >
  face (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceType > r (
      ::bml::face (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceType >
  face (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceType > r (
      ::bml::face (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::face (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::face (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::face (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::face (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::face (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::face (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::faceType > r (
      ::bml::face (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceType > r (
      ::bml::face (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceType > r (
      ::bml::face (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceType >
  face (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::faceType > r (
        ::bml::face (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "face" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::faceType > r (
        ::xsd::cxx::tree::traits< ::bml::faceType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "face",
      "bml");
  }

  ::std::auto_ptr< ::bml::faceType >
  face (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "face" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::faceType > r (
        ::xsd::cxx::tree::traits< ::bml::faceType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "face",
      "bml");
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::faceShiftType > r (
      ::bml::faceShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceShiftType > r (
      ::bml::faceShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceShiftType > r (
      ::bml::faceShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceShift (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::faceShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceShift (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::faceShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::faceShiftType > r (
      ::bml::faceShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceShiftType > r (
      ::bml::faceShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::faceShiftType > r (
      ::bml::faceShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::faceShiftType > r (
        ::bml::faceShift (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "faceShift" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::faceShiftType > r (
        ::xsd::cxx::tree::traits< ::bml::faceShiftType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "faceShift",
      "bml");
  }

  ::std::auto_ptr< ::bml::faceShiftType >
  faceShift (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "faceShift" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::faceShiftType > r (
        ::xsd::cxx::tree::traits< ::bml::faceShiftType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "faceShift",
      "bml");
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::lexemeType > r (
      ::bml::lexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::lexemeType > r (
      ::bml::lexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::lexemeType > r (
      ::bml::lexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::lexeme (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::lexeme (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::lexeme (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::lexeme (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::lexeme (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::lexeme (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::lexemeType > r (
      ::bml::lexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::lexemeType > r (
      ::bml::lexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::lexemeType > r (
      ::bml::lexeme (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::lexemeType > r (
        ::bml::lexeme (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "lexeme" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::lexemeType > r (
        ::xsd::cxx::tree::traits< ::bml::lexemeType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "lexeme",
      "bml");
  }

  ::std::auto_ptr< ::bml::lexemeType >
  lexeme (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "lexeme" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::lexemeType > r (
        ::xsd::cxx::tree::traits< ::bml::lexemeType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "lexeme",
      "bml");
  }

  ::std::auto_ptr< ::bml::headType >
  head (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::headType > r (
      ::bml::head (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headType >
  head (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::headType > r (
      ::bml::head (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headType >
  head (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::headType > r (
      ::bml::head (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headType >
  head (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::head (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::headType >
  head (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::head (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::headType >
  head (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::head (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::headType >
  head (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::head (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::headType >
  head (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::head (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::headType >
  head (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::head (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::headType >
  head (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::headType > r (
      ::bml::head (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headType >
  head (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::headType > r (
      ::bml::head (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headType >
  head (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::headType > r (
      ::bml::head (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::headType >
  head (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::headType > r (
        ::bml::head (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "head" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::headType > r (
        ::xsd::cxx::tree::traits< ::bml::headType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "head",
      "bml");
  }

  ::std::auto_ptr< ::bml::headType >
  head (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "head" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::headType > r (
        ::xsd::cxx::tree::traits< ::bml::headType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "head",
      "bml");
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::postureShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::postureShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::postureShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::postureShift (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::postureShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::postureShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::postureShift (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::postureShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::postureShift (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::postureShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::postureShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::postureType > r (
      ::bml::postureShift (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::postureType > r (
        ::bml::postureShift (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "postureShift" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::postureType > r (
        ::xsd::cxx::tree::traits< ::bml::postureType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "postureShift",
      "bml");
  }

  ::std::auto_ptr< ::bml::postureType >
  postureShift (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "postureShift" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::postureType > r (
        ::xsd::cxx::tree::traits< ::bml::postureType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "postureShift",
      "bml");
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::stanceType > r (
      ::bml::stance (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::stanceType > r (
      ::bml::stance (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::stanceType > r (
      ::bml::stance (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::stance (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::stance (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::bml::stance (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::stance (isrc, f, p);
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::stance (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::bml::stance (isrc, h, f, p);
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::bml::stanceType > r (
      ::bml::stance (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::stanceType > r (
      ::bml::stance (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::bml::stanceType > r (
      ::bml::stance (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::bml::stanceType > r (
        ::bml::stance (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "stance" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::stanceType > r (
        ::xsd::cxx::tree::traits< ::bml::stanceType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "stance",
      "bml");
  }

  ::std::auto_ptr< ::bml::stanceType >
  stance (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "stance" &&
        n.namespace_ () == "bml")
    {
      ::std::auto_ptr< ::bml::stanceType > r (
        ::xsd::cxx::tree::traits< ::bml::stanceType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "stance",
      "bml");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

